diff --git a/src/commands/multiple-cursors.lisp b/src/commands/multiple-cursors.lisp
index 339463e2ebf94d7eda22cd80df89a4e95208d6c7..3beb08d451f7dee7b6c375181509368500398ba2 100644
--- a/src/commands/multiple-cursors.lisp
+++ b/src/commands/multiple-cursors.lisp
@@ -1,43 +1,44 @@
 (defpackage :lem-core/commands/multiple-cursors
   (:use :cl :lem-core)
+  (:shadow #:clear-cursors)
   (:export #:add-cursors-to-next-line
            #:add-cursors-to-previous-line
            #:add-cursors-to-right
            #:add-cursors-to-left
            #:clear-cursors
            #:move-to-next-fake-cursor
            #:move-to-previous-fake-cursor)
   #+sbcl
   (:lock t))
 (in-package :lem-core/commands/multiple-cursors)
 
 (define-key *global-keymap* "C-M-Down" 'add-cursors-to-next-line)
 (define-key *global-keymap* "C-M-Up" 'add-cursors-to-previous-line)
 (define-key *global-keymap* "C-M-Right" 'add-cursors-to-right)
 (define-key *global-keymap* "C-M-Left" 'add-cursors-to-left)
-(define-Key *global-keymap* "C-M-c" 'clear-cursors)
+(define-key *global-keymap* "C-M-c" 'clear-cursors)
 
 (defun duplicate-cursors (&key line-step char-step move-fn duplicate-p (n 1))
   (declare (type (or null fixnum) line-step char-step)
            (type (or null function) move-fn)
            (type function duplicate-p)
            (type fixnum n)
            (optimize (speed 3) (safety 2)))
   (let ((cursors (buffer-cursors (current-buffer))))
     (declare (type (list lem:cursor) cursors))
     (loop :for (cursor next-cursor) :on cursors
           :do (with-point ((p cursor))
                 (declare (type lem:cursor cursor next-cursor)
                          (type lem/buffer/internal:point p))
                 (let ((column (point-charpos p)))
                   (declare (type fixnum column))
                   (dotimes (i (or n 1))
                     (declare (ignore i))
                     (let ((moved (cond (move-fn (funcall move-fn p))
                                        (line-step (line-offset p line-step (or char-step column)))
                                        (char-step (character-offset p char-step))
                                        (t nil))))
                       (unless moved (return))
                       (when (or (null next-cursor)
                                 (not (funcall duplicate-p p next-cursor)))
                         (make-fake-cursor p))))))))
@@ -99,40 +100,38 @@
   (declare (type (or null fixnum) n))
   (let ((n (or n 1)))
     (declare (type fixnum n))
     (cycle-real-cursor n)))
 
 (define-command move-to-previous-fake-cursor (n) (:universal-nil)
   "Move the real cursor to the Nth previous fake cursor."
   (declare (type (or null fixnum) n))
   (let ((n (or n 1)))
     (declare (type fixnum n))
     (cycle-real-cursor (- n))))
 
 (defun clear-duplicate-cursors (buffer)
   (declare (type lem:buffer buffer)
            (optimize (speed 3) (safety 2)))
   (loop :for (cursor next-cursor) :on (buffer-cursors buffer)
         :do (declare (type lem:cursor cursor next-cursor))
         :when (and next-cursor (same-line-p cursor next-cursor))
         :do (delete-fake-cursor
              (if (eq cursor (buffer-point buffer))
                  next-cursor
                  cursor))))
 
 (define-command clear-cursors () ()
   "Clear all cursors in the current buffer."
-  (let ((buffer (current-buffer)))
-    (declare (type lem:buffer buffer))
-    (clear-duplicate-cursors buffer)))
+  (lem-core:clear-cursors (current-buffer)))
 
 (defun garbage-collection-cursors ()
   (clear-duplicate-cursors (current-buffer)))
 
 (add-hook *post-command-hook* 'garbage-collection-cursors)
 
 (defun clear-cursors-when-aborted ()
   (let ((string (merge-cursor-killrings (current-buffer))))
-    (clear-cursors (current-buffer))
+    (lem-core:clear-cursors (current-buffer))
     (copy-to-clipboard-with-killring string)))
 
 (add-hook *editor-abort-hook* 'clear-cursors-when-aborted)
diff --git a/src/ext/isearch.lisp b/src/ext/isearch.lisp
index d565b1b6ed70e1fa5a60f9e38839f604b272aa54..6598baf033f00d3785d4dd0c3969084ca701a518 100644
--- a/src/ext/isearch.lisp
+++ b/src/ext/isearch.lisp
@@ -7,50 +7,51 @@
            :isearch-mode
            :isearch-highlight-attribute
            :isearch-highlight-active-attribute
            :isearch-forward
            :isearch-backward
            :isearch-forward-regexp
            :isearch-backward-regexp
            :isearch-forward-symbol
            :isearch-backward-symbol
            :isearch-forward-symbol-at-point
            :isearch-abort
            :isearch-delete-char
            :isearch-raw-insert
            :isearch-end
            :isearch-finish
            :isearch-next
            :isearch-prev
            :isearch-yank
            :isearch-self-insert
            :isearch-replace-highlight
            :isearch-next-highlight
            :isearch-prev-highlight
            :isearch-toggle-highlighting
            :isearch-add-cursor-to-next-match
            :isearch-add-cursor-to-prev-match
+           :isearch-add-cursor-to-all-matches
            :read-query-replace-args
            :query-replace
            :query-replace-regexp
            :query-replace-symbol)
   #+sbcl
   (:lock t))
 (in-package :lem/isearch)
 
 (defvar *isearch-keymap* (make-keymap :name '*isearch-keymap*
                                       :undef-hook 'isearch-self-insert))
 (defvar *isearch-prompt*)
 (defvar *isearch-string*)
 (defvar *isearch-previous-string* nil)
 (defvar *isearch-start-point*)
 (defvar *isearch-search-function*)
 (defvar *isearch-search-forward-function*)
 (defvar *isearch-search-backward-function*)
 (defvar *isearch-popup-message* nil)
 (defvar *isearch-finish-hooks* '())
 
 (define-attribute isearch-highlight-attribute
   (t :foreground :base00 :background :base05))
 
 (define-attribute isearch-highlight-active-attribute
   (t :foreground :base00 :background :base0D))
@@ -493,75 +494,93 @@
 
 (define-command isearch-toggle-highlighting () ()
   (cond
     ((isearch-overlays (current-buffer))
      (isearch-end))
     ((boundp '*isearch-string*)
      (isearch-update-buffer))))
 
 (defun determine-start-end-current-search (point string is-forward)
   (with-point ((start point)
                (end point))
     (if is-forward
         (progn
           (funcall *isearch-search-forward-function* end string)
           (funcall *isearch-search-backward-function* (move-point start end) string))
         (progn
           (funcall *isearch-search-backward-function* start string)
           (funcall *isearch-search-forward-function* (move-point end start) string)))
     (list start end)))
 
 (defun mark-by-direction (is-forward buffer)
   (alexandria:when-let* ((string (or (buffer-value (current-buffer) 'isearch-redisplay-string)
                                      (and (boundp '*isearch-string*)
                                           *isearch-string*))))
     (let* ((cur-p (current-point))
-           (start-end (determine-start-end-current-search cur-p string is-forward))
-           (start (first start-end))
-           (end (second start-end))
-           (offset-pos (cond
-                         ((and (point= start cur-p) is-forward) (length string))
-                         ((and (point= end cur-p) (not is-forward)) (* -1 (length string)))
-                         (t 0)))
-           (cursors (buffer-cursors buffer))
-           (sorted-cursors (if is-forward (reverse cursors) cursors))
-           (cursor (first sorted-cursors)))
-      (with-point ((point cursor))
-        (character-offset point offset-pos)
-        (if (search-next-matched point (if is-forward 1 0))
-            (progn
-              (character-offset point (* -1 offset-pos))
-              (make-fake-cursor point)
-              (message "Mark set ~A" (+ (length cursors) 1)))
-            (message "No more matches found"))))))
+           (string-length (length string)))
+      (destructuring-bind (start end)
+          (determine-start-end-current-search cur-p string is-forward)
+        (let* ((offset-pos (cond
+                             ((and (point= start cur-p) is-forward) string-length)
+                             ((and (point= end cur-p) (not is-forward)) (* -1 string-length))
+                             (t 0)))
+               (cursors (buffer-cursors buffer))
+               (sorted-cursors (if is-forward (reverse cursors) cursors))
+               (cursor (first sorted-cursors)))
+          (with-point ((point cursor))
+            (character-offset point offset-pos)
+            (if (search-next-matched point (if is-forward 1 0))
+                (progn
+                  (character-offset point (- offset-pos))
+                  (make-fake-cursor point)
+                  (message "Mark set ~A" (1+ (length cursors))))
+                (message "No more matches found")))))))
 
 (define-command isearch-add-cursor-to-next-match () ()
   (mark-by-direction t (current-buffer)))
 
 (define-command isearch-add-cursor-to-prev-match () ()
   (mark-by-direction nil (current-buffer)))
 
+(define-command isearch-add-cursor-to-all-matches () ()
+  (alexandria:when-let ((string (or (buffer-value (current-buffer) 'isearch-redisplay-string)
+                                    (and (boundp '*isearch-string*)
+                                         *isearch-string*))))
+    (let* ((buffer (current-buffer))
+           (string-length (length string))
+           (search-fn *isearch-search-forward-function*)
+           (search-back-fn *isearch-search-backward-function*)
+           (current (current-point)))
+      (with-point ((p (buffer-start-point buffer)))
+        (loop :while (funcall search-fn p string)
+              :do (with-point ((start p))
+                    (funcall search-back-fn start string)
+                    (unless (point= start current)
+                      (make-fake-cursor start))
+                    (move-point p start)
+                    (character-offset p string-length))))
+      (message "Mark set ~A" (length (buffer-cursors buffer))))))
 
 (defvar *replace-before-string* nil)
 (defvar *replace-after-string* nil)
 
 (defun read-query-replace-args ()
   (let ((before)
         (after))
     (setq before
           (prompt-for-string
            (if *replace-before-string*
                (format nil "Before (~a with ~a): "
                        *replace-before-string*
                        *replace-after-string*)
                "Before: ")))
     (when (equal "" before)
       (cond (*replace-before-string*
              (setq before *replace-before-string*)
              (setq after *replace-after-string*)
              (return-from read-query-replace-args
                (list before after)))
             (t
              (message "Before string is empty")
              (return-from read-query-replace-args
                (list nil nil)))))
     (setq after (prompt-for-string "After: "))
